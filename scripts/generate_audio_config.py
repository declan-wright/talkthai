#!/usr/bin/env python3
"""
Automatically generate audio_config.py from TypeScript reading lesson files.
Extracts Thai text for each audio file by parsing the TypeScript data structures.
"""

import re
import json
from pathlib import Path
from collections import defaultdict

def extract_audio_mappings(ts_content):
    """Extract audioFile -> Thai text mappings from TypeScript content."""
    mappings = {}

    # Pattern 1: Objects with character/nameWord and audioFile
    # { character: 'ก', nameWord: 'ไก่', audioFile: '/audio/...' }
    pattern1 = r"character:\s*['\"]([^'\"]+)['\"].*?nameWord:\s*['\"]([^'\"]+)['\"].*?audioFile:\s*['\"]([^'\"]+)['\"]"
    for match in re.finditer(pattern1, ts_content, re.DOTALL):
        char, word, audio_path = match.groups()
        text = f"{char} {word}"
        mappings[audio_path] = text

    # Pattern 2: Objects with syllable and audioFile
    # { syllable: 'กา', audioFile: '/audio/...' }
    pattern2 = r"syllable:\s*['\"]([^'\"]+)['\"].*?audioFile:\s*['\"]([^'\"]+)['\"]"
    for match in re.finditer(pattern2, ts_content, re.DOTALL):
        syllable, audio_path = match.groups()
        if audio_path not in mappings:  # Don't overwrite character mappings
            mappings[audio_path] = syllable

    # Pattern 3: Objects with thai and audioFile
    # { thai: 'กา', audioFile: '/audio/...' }
    pattern3 = r"thai:\s*['\"]([^'\"]+)['\"].*?audioFile:\s*['\"]([^'\"]+)['\"]"
    for match in re.finditer(pattern3, ts_content, re.DOTALL):
        thai, audio_path = match.groups()
        if audio_path not in mappings:
            mappings[audio_path] = thai

    # Pattern 4: Vowel examples without explicit thai/syllable
    # exampleWithKɔɔ: 'กา', audioFile: '/audio/vowels/aa.wav'
    pattern4 = r"exampleWithKɔɔ:\s*['\"]([^'\"]+)['\"].*?audioFile:\s*['\"]([^'\"]+)['\"]"
    for match in re.finditer(pattern4, ts_content, re.DOTALL):
        thai, audio_path = match.groups()
        if audio_path not in mappings:
            mappings[audio_path] = thai

    return mappings

# Read all TypeScript files
all_mappings = {}
reading_dir = Path("data/reading")

for ts_file in reading_dir.glob("*.ts"):
    content = ts_file.read_text()
    mappings = extract_audio_mappings(content)
    all_mappings.update(mappings)

print(f"Extracted {len(all_mappings)} audio file mappings")

# Organize by category
by_category = defaultdict(list)

for audio_path, text in sorted(all_mappings.items()):
    path = audio_path.replace("/audio/", "")

    # Convert .wav to .opus in filename
    path = path.replace('.wav', '.opus')

    if path.startswith("characters/"):
        category = "CHARACTERS"
        filename = path.replace("characters/", "")
        subdirectory = None
        priority = "HIGH"
    elif path.startswith("vowels/syllables/"):
        category = "VOWEL_SYLLABLES"
        filename = path.replace("vowels/syllables/", "")
        subdirectory = "syllables"
        priority = "MEDIUM"
    elif path.startswith("vowels/placement-"):
        category = "VOWEL_PLACEMENT"
        filename = path.replace("vowels/", "")
        subdirectory = None
        priority = "HIGH"
    elif path.startswith("vowels/endings/"):
        category = "ENDING_CONSONANTS"
        filename = path.replace("vowels/endings/", "")
        subdirectory = "endings"
        priority = "MEDIUM"
    elif path.startswith("vowels/"):
        category = "VOWELS"
        filename = path.replace("vowels/", "")
        subdirectory = None
        priority = "MEDIUM"
    else:
        category = "OTHER"
        filename = path
        subdirectory = None
        priority = "LOW"

    by_category[category].append({
        "filename": filename,
        "text": text,
        "subdirectory": subdirectory,
        "priority": priority
    })

# Generate Python code
output_lines = [
    '"""',
    'Unified Audio Configuration for Thai Learning App',
    '',
    'Auto-generated from TypeScript reading lesson files.',
    'DO NOT EDIT THIS FILE MANUALLY - Run scripts/generate_audio_config.py instead.',
    '"""',
    '',
    'from dataclasses import dataclass',
    'from enum import Enum',
    'from typing import Optional',
    '',
    '',
    'class AudioCategory(Enum):',
    '    CHARACTERS = "characters"',
    '    VOWELS = "vowels"',
    '    VOWEL_SYLLABLES = "vowel-syllables"',
    '    VOWEL_PLACEMENT = "vowel-placement"',
    '    ENDING_CONSONANTS = "ending-consonants"',
    '',
    '',
    'class Priority(Enum):',
    '    HIGH = "high"',
    '    MEDIUM = "medium"',
    '    LOW = "low"',
    '',
    '',
    '@dataclass',
    'class AudioRequirement:',
    '    """Represents a single audio file that needs to be generated."""',
    '    id: str',
    '    category: AudioCategory',
    '    filename: str',
    '    text: str',
    '    priority: Priority = Priority.MEDIUM',
    '    subdirectory: Optional[str] = None',
    '    voice: str = "Kore"  # Default Gemini TTS voice for Thai',
    '    instructions: str = "read slowly and pronounce the tones clearly"',
    '',
    ''
]

# Generate each category
for category_name, items in sorted(by_category.items()):
    output_lines.append(f"# {'='*77}")
    output_lines.append(f"# {category_name} AUDIO ({len(items)} files)")
    output_lines.append(f"# {'='*77}")
    output_lines.append(f"{category_name}_AUDIO = [")

    for item in items:
        id_part = item['filename'].replace('.wav', '').replace('.', '-')
        subdir_str = f'"{item["subdirectory"]}"' if item['subdirectory'] else 'None'

        output_lines.append(f"    AudioRequirement(")
        output_lines.append(f'        id="{category_name.lower()}-{id_part}",')
        output_lines.append(f'        category=AudioCategory.{category_name},')
        output_lines.append(f'        filename="{item["filename"]}",')
        output_lines.append(f'        text="{item["text"]}",')
        output_lines.append(f'        priority=Priority.{item["priority"]},')
        output_lines.append(f'        subdirectory={subdir_str},')
        output_lines.append(f"    ),")

    output_lines.append(f"]")
    output_lines.append("")
    output_lines.append("")

# Add aggregation
output_lines.extend([
    "# =============================================================================",
    "# ALL AUDIO REQUIREMENTS",
    "# =============================================================================",
    "ALL_AUDIO_REQUIREMENTS = (",
])

for category_name in sorted(by_category.keys()):
    output_lines.append(f"    {category_name}_AUDIO +")

output_lines[-1] = output_lines[-1].rstrip(" +")  # Remove trailing +
output_lines.append(")")
output_lines.append("")
output_lines.append("")

# Add helper functions
output_lines.extend([
    "def get_requirements_by_category(category: AudioCategory) -> list[AudioRequirement]:",
    '    """Get all audio requirements for a specific category."""',
    "    return [req for req in ALL_AUDIO_REQUIREMENTS if req.category == category]",
    "",
    "",
    "def get_requirements_by_priority(priority: Priority) -> list[AudioRequirement]:",
    '    """Get all audio requirements for a specific priority level."""',
    "    return [req for req in ALL_AUDIO_REQUIREMENTS if req.priority == priority]",
    "",
    "",
    "def get_stats() -> dict:",
    '    """Get statistics about audio requirements."""',
    "    return {",
    '        "total": len(ALL_AUDIO_REQUIREMENTS),',
    '        "by_category": {',
    "            category.value: len(get_requirements_by_category(category))",
    "            for category in AudioCategory",
    "        },",
    '        "by_priority": {',
    "            priority.value: len(get_requirements_by_priority(priority))",
    "            for priority in Priority",
    "        },",
    "    }",
])

# Write the file
output_file = Path("data/audio_config.py")
output_file.write_text("\n".join(output_lines) + "\n")

print(f"\n✅ Generated {output_file}")
print(f"\nSummary:")
for cat, items in sorted(by_category.items()):
    print(f"  {cat}: {len(items)} files")
print(f"\nTotal: {sum(len(items) for items in by_category.values())} audio files")
